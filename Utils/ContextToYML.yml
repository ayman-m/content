commonfields:
  id: ContextToYML
  version: 2
name: ContextToYML
script: |

  """
  This script parse a Context output into yml formatted file with the context path of each field.
  For example:
  {
      "id":12131,
      ....
      "issuetype":{
          "id":10004,
          "name":"Bug"
      },
      "project":{
          "id":10001,
          ...
      },
      "status":{
          "id":10003,
              "StatusCategory":{
                  "key":"new",
                  ....
          }
      }
  }
  ==>
  arguments: []
  name: integration-command
  outputs:
  - contextPath: Demisto.Id
    description: ''
    type: Number
  - contextPath: Demisto.Description
    description: ''
    type: String
  - contextPath: Demisto.Summary
    description: ''
    type: String
  - contextPath: Demisto.Created
    description: ''
    type: String
  - contextPath: Demisto.Issuetype.Id
    description: ''
    type: Number
  - contextPath: Demisto.Issuetype.Name
    description: ''
    type: String
  - contextPath: Demisto.Project.Id
    description: ''
    type: Number
  - contextPath: Demisto.Project.Key
    description: ''
    type: String
  - contextPath: Demisto.Project.ProjectTypeKey
    description: ''
    type: String
  - contextPath: Demisto.Status.Id
    description: ''
    type: Number
  - contextPath: Demisto.Status.StatusCategory.Key
    description: ''
    type: String
  - contextPath: Demisto.Status.StatusCategory.Colorname
    description: ''
    type: String
  - contextPath: Demisto.Status.StatusCategory.Name
    description: ''
    type: String
  """
  import yaml
  dArgs = demisto.args()
  VERBOSE = dArgs.get('verbose') == 'true'
  CAMELIZE = dArgs.get('camelize', 'false') == 'true'


  def flatten_json(nested_json):
      out = {}

      def flatten(x, name=''):
          # capitalize first letter in each key
          try:
              name = name[0].upper() + name[1:] if CAMELIZE else name
          except IndexError:
              name = name.title() if CAMELIZE else name

          if isinstance(x, dict):
              for a in x:
                  flatten(x[a], name + a + '.')
          elif isinstance(x, list):
              for a in x:
                  flatten(a, name[:-1] + '.')
          else:
              out[name.rstrip('.')] = x

      flatten(nested_json)
      return out


  def jsonise(context_key, value):
      return {'contextPath': context_key, 'description': '', 'type': determine_type(value)}


  def determine_type(val):
      return 'Boolean' if isinstance(val, bool) else 'Number' if isinstance(
          val, (int, float)) else 'String' if isinstance(val, str) else 'Unknown'


  def parse_json(data, command_name, base_path):
      flattened_data = flatten_json(data)
      if base_path:
          flattened_data = {f'{base_path.title()}.{key}': value for key, value in flattened_data.items()}

      arg_json = [jsonise(key, value) for key, value in flattened_data.items()]

      if VERBOSE:
          print(f'JSON before converting to YAML: {arg_json}')

      yaml_output = yaml.safe_dump(
          {
              'name': command_name.lstrip('!'),
              'arguments': [],
              'outputs': arg_json
          },
          default_flow_style=False
      )
      return yaml_output


  def main():
      command_name = dArgs.get("command_name", '')
      base_path = dArgs.get("base_path", '')
      entry_id = dArgs.get("json_file_entry_id")
      json_file_as_text = dArgs.get("json_file_as_text")

      yaml_output = ''
      if json_file_as_text:
          if not base_path:
              demisto.results('please enter base path for context output')

          yaml_output = parse_json(json.loads(json_file_as_text), command_name, base_path)

      if entry_id:
          if not base_path:
              demisto.results('please enter base path for context output')

          json_file_path = demisto.getFilePath(entry_id)['path']
          with open(json_file_path, 'r') as json_file:
              yaml_output = parse_json(json.load(json_file), command_name, base_path)

      filename = f'{command_name}-outputs.yml'
      demisto.results({
          'Type': entryTypes['note'],
          'ContentsFormat': formats['markdown'],
          'Contents': yaml_output,
          'HumanReadable': yaml_output,
      })
      demisto.results(fileResult(filename, yaml_output.encode(), file_type=entryTypes['entryInfoFile']))


  if __name__ in ['__main__', '__builtin__', 'builtins']:
      main()
type: python
tags: []
comment: Turns context output into yml formatted file with the context path of each
  field.
enabled: true
args:
- name: command_name
  description: Command name.
  required: true
- name: base_path
  description: Base path for context outputs.
- name: json_file_entry_id
  description: Raw output file in json format. Will return context outputs as should
    be in the yml file.
- name: json_file_as_text
  description: Raw output file in json format as text, or context output of the command.
    Will return context outputs as should be in the yml file.
- name: camelize
  auto: PREDEFINED
  predefined:
  - "true"
  - "false"
  description: if true, returns camelized keys in context
  defaultValue: "false"
- name: verbose
  auto: PREDEFINED
  predefined:
  - "true"
  - "false"
  description: if true, prints the json before converting to yml.
  defaultValue: "false"
scripttarget: 0
runonce: false
dockerimage: demisto/python3:3.7.4.1150
runas: DBotWeakRole
